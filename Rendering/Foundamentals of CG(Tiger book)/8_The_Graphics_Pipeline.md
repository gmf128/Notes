# 8：The Graphics Pipeline

**图形管线**

## 8.1 流程

object-order的渲染方式在流程上大体是一样的，这一样的流程被成为图形渲染管线。

**object-order渲染工作主要分为三种：**

1. **光栅化**
2. **光栅化之前的几何操作**（例：transformation matrix)
3. **光栅化之后的逐像素操作（pixelwise)** （例：逐像素判断遮蔽关系，zbuffer）

图形渲染管线的主要流程：

![]( https://box.nju.edu.cn/f/35870112f7bf4f55aed5/?dl=1 )

- vertex processing：大多数三维模型都是以点集的形式表示的，最常用的三角形面片即是如此。得到“primitive”
- rasterization：将primitive拆为fragments；
- fragments：概念：对应每一个像素。存储一些该像素在渲染过程的中间量
- blending

## 8.2 光栅化

光栅化主要做两件事：

1. 遍历源几何原型（primitive）遮盖的所有像素
2. 插值。得到每个像素对应fragment的中间量

### 8.2.1 画线算法

**算法：中点法**

原理：

- 不妨假设要画的直线是斜率大于0，且小于1的“不太陡峭的”直线，即
  $$
  f(x, y) ≡ (y_0 − y_1)x + (x_1 − x_0)y + x_0y_1 − x_1y_0 = 0
  $$

$$
m = \frac{y_1 − y_0}
  {x_1 − x_0}
$$

​		满足m在(0, 1]内，对于其他情况，都可以通过坐标变换变为这种情况。

- 我们可以循环地令x++，每一次x++，y可能不变，可能+1.

- 判断是不变还是+1的依据：y不变和+1对应的两个像素的中点是在目标直线之上还是之下？之下就不变，之上就++。即：
  $$
  f(x+1, y+0.5)>0\ ? \ f(x+1, y+0.5)<0?
  $$
  

![]( https://box.nju.edu.cn/f/a1575d8b0b9d4140a611/?dl=1 )

在实际操作时，我们可以不必每次都计算f(x+1,y)的值，而是利用以下递推：
$$
f(x + 1, y) = f(x, y)+(y_0 − y_1)
$$

$$
f(x + 1, y + 1) = f(x, y)+(y_0 − y_1)+(x_1 − x_0).
$$

因此，算法的伪代码可以表示为：

```pascal
y = y0
d = f(x0 + 1, y0 + 0.5)
for x = x0 to x1 do
	draw(x, y)
	if d < 0 then
		y = y + 1
		d = d + (x1 − x0)+(y0 − y1)
	else
		d = d + (y0 − y1)
```

### 8.2.2 画三角形

#### 8.2.2.1 Gouraud插值

若三角形三个顶点颜色分别为c0, c1, c2；重心坐标为（alpha, betam, gamma）则三角形内任一点的颜色可以被表达为
$$
\bold{c} = α\bold{c_0} + β\bold{c_1} + γ\bold{c_2}
$$
brute-force：

```pascal
for all x do
	for all y do
		compute (α, β, γ) for (x, y)
		if (α ∈ [0, 1] and β ∈ [0, 1] and γ ∈ [0, 1]) then
			c = αc0 + βc1 + γc2
			drawpixel (x, y) with color c
```

加入bounding-box进行改进

```pascal
xmin = floor(xi)
xmax = ceiling(xi)
ymin = floor(yi)
ymax = ceiling(yi)
for y = ymin to ymax do
	for x = xmin to xmax do
		α = f12(x, y)/f12(x0, y0)
		β = f20(x, y)/f20(x1, y1)
		γ = f01(x, y)/f01(x2, y2)
		if (α > 0 and β > 0 and γ > 0) then
			c = αc0 + βc1 + γc2
			drawpixel (x, y) with color c
```

#### 8.2.2.2 边界情况处理

对于像素中心恰好处于两个三角形共边的像素，需要额外处理。否则会造成双重处理double-coloring，当存在alpha通道时这将会导致错误。

因此我们希望能够找到一种将边界点划分给三角形中的某一个的方法。

offset-point法：找一个位于平面外的点（比如（-1， -1）），任何不通过该点的直线一定将平面分为两部分，和该点在同一侧的与和该点在异侧的。因此，我们总可以选择和该点在同侧的三角形作为将共享边划分的三角形。

![]( https://box.nju.edu.cn/f/c6cfcb89a5344bfcb918/?dl=1 )

```pascal
xmin = floor(xi)
xmax = ceiling(xi)
ymin = floor(yi)
ymax = ceiling(yi)
fα = f12(x0, y0)
fβ = f20(x1, y1)
fγ = f01(x2, y2)
for y = ymin to ymax do
	for x = xmin to xmax do
		α = f12(x, y)/fα
		β = f20(x, y)/fβ
		γ = f01(x, y)/fγ
		if (α ≥ 0 and β ≥ 0 and γ ≥ 0) then
			if (α > 0 or fαf12(−1, −1) > 0) and
			(β > 0 or fβf20(−1, −1) > 0) and
			(γ > 0 or fγf01(−1, −1) > 0) then
				c = αc0 + βc1 + γc2
				drawpixel (x, y) with color c
```

局限：

1. 仍需处理直线恰好通过界外点的情况
2. 此时将导致意外：当两个三角形顶点排布顺序不一致时（顺时针/逆时针）此时共边的直线方程肯差正负号，需要注意。

### 8.2.3 Clipping

![]( https://box.nju.edu.cn/f/dd833887f8aa4d449b01/?dl=1 )

如图所示，当z>n时尤其z>0会发生异常情况，所以需要我们对投影变换的结果做一定的剪裁

具体处理这篇笔记写的非常好，可以代劳： [计算机图形学补充2：齐次空间裁剪(Homogeneous Space Clipping) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/162190576) 

核心公式：

平面定义：
$$
f(p) = n · p + D = 0
$$
直线定义（插值）：
$$
p = a + t(b − a)
$$
带入解t：
$$
n · (a + t(b − a)) + D = 0
$$

$$
t =\frac{n · a + D} {n · (a − b)}
$$

带入得到边缘点，之后就是重组为两个三角形。

## 8.3 光栅化之前和之后

**光栅化要做的事情比想象中的少，可以理解为它只做一个“离散化”的操作，得到各个像素进行后续步骤的信息（如给深度信息到z-buffer的过程）**

例如根据z-buffer来判断遮蔽关系并不是“rasterization”的工作，而是“after rasterization”的工作，**raster的工作只是得到每一个像素的深度信息，作为fragment的一个“attribute”，如何运用深度信息生成最终的颜色则是raster之后的工作了**。

因此：

- 光栅化之前需要做到：

  1. 将3D坐标经过投影、视口变换转变为屏幕坐标

  2. 准备好颜色、平面法向量、纹理坐标以待使用
  
- 光栅化之前需要做到：

  1. 继续处理fragment的信息，比如zbuffer比较深度取最小值

  2. **blending**，也就是根据fragment的各种信息经过或简单或复杂的着色过程生成每个像素最终的过程
  
  3. 原文中这点令人寻味：
  
     >  Finally, the blending phase combines the fragments generated by the (**possibly several**) primitives that overlapped each pixel to compute the final color。
  
     可能存在用好几个物体生成一个像素颜色的可能性，这让我联想到“SoftRas”不像光栅化这种想法是肤浅的。

### 8.3.1 z-buffer算法

对每个pixel多储存一种信息：即深度信息

>  The z-buffer algorithm is implemented in the fragment blending phase, by comparing the depth **of each fragment** with the current value stored in the z-buffer 

**注意：fragment是1个三维物体+1个像素对应1个fragment，一个像素可以对应多个frament，来自不同的物体。**

>  In practice, the z-values stored in the buffer **are nonnegative integers. This is preferable to true floats** because the fast memory needed for the z-buffer is somewhat expensive and is worth keeping to a minimum. 

trade-off后，z值一般被存储为非负整数而非较为精确的浮点数。

如果我们有0-B-1个整数来表达深度信息，那我们会将0来表达z=n(z=1)，用B-1表达z=f(z=-1)。如果我们用b位来存储z-buffer，那么B=2^b。

在[-1, 1]^3的正则空间中，我们可以将深度分为B份，取值范围在同一份的z值认为相等
$$
\Delta z = \frac{2}{B}
$$
由投影公式：
$$
z = \frac{n+f}{n-f}+\frac{2nf}{(n-f)z_w}
$$
得到近似：
$$
\Delta z \approx -\frac{2nf}{(n-f)z_w^2}\Delta z_w
$$
由此可以估计在真实坐标中的深度值误差。

### 8.3.2 per-vertex shading

即Gouraud-shading 需要顶点法向量

操作：利用顶点法向量在顶点处依照反射模型渲染，然后中间进行颜色插值

### 8.3.3 per-fragment shading

又称Phong Shading

同样需要顶点法向量，但是不一样的是：中间进行向量插值，然后对每个fragment进行计算着色



对比：

- per-vertex计算顶点颜色发生在vertex-processing这一步，rasterization中进行颜色插值，fragment processing没有什么工作。
- per-fragment在vertex-processing时没有什么工作，rasterization时进行向量插值，不生成颜色，fragment processing时计算颜色。

效果对比：

<img src=" https://box.nju.edu.cn/f/30ab5c4721104389a9c0/?dl=1" style="zoom:50%;" />

### 8.3.4 texture mapping

将纹理的uv坐标同样作为顶点的信息，进而在光栅化和fragment-processing中利用

### 8.3.5 渲染频率

需要的渲染频率的高低取决于物体投影到屏幕后的大小，如果投影后很小，说明颜色变换非常剧烈，需要更高的采样/渲染频率

vertex-shading适合高频；fragment-shading更适合低频

### 8.3.6 反走样

**超采样**的概念（super-sampling)：例子：要渲染256\*256的图片，先渲染出一个1024\*1024的图片，之后再通过每4\*4取平均降低分辨率。

### 8.3.7 Culling剔除

在渲染非常复杂的场景时，例如城市，在任何一个时刻，相机能够看到的物体是有限的，大多数物体要么在视锥之外，要么被其他物体遮挡，对于最终渲染图片的生成没有贡献或贡献及其微小。然而，在object-order渲染过程中，我们却需要将全部场景物体扫描并转换，这之中自然包括了那些无贡献的物体，这大量浪费了算力。因此，剔除那些无效的物体是十分有必要的。

- view volume culling（view frustum culling) —the removal of geometry that is outside the view volume; 
- occlusion culling—the removal of geometry that may be within the view volume but is obscured, or occluded, by other geometry closer to the camera; 
- backface culling—the removal of primitives facing away from the camera. 

#### 8.3.7.1 视锥剔除

中心思想：如果一个物体完全在视锥之外，那么抛弃之。

常用方法：物体有包围盒。利用包围盒来剔除。如球形包围盒，通过判断球心到视锥某平面的距离和半径的关系即可。

#### 8.3.7.2 背面剔除

![]( https://box.nju.edu.cn/f/bf4be41e262143b5912a/?dl=1 )

注意，这里的背面三角形一定是在一个**立体封闭物体**上的，意思是**不透明物体的背面是不需要渲染**的。

